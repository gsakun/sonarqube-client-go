package generate

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	gen "github.com/dave/jennifer/jen"
	"github.com/magicsong/color-glog"

	"github.com/magicsong/generate-go-for-sonarqube/pkg/api"
	"github.com/magicsong/generate-go-for-sonarqube/pkg/response"
	"github.com/magicsong/generate-go-for-sonarqube/pkg/util/strcase"
)

var (
	DeprecatedWords = []string{"removed", "deprecated"}
	validation      *gen.File
	client          *gen.File
	WorkingDir      string
	PackageName     string
	services        []string
	Endpoint        string
	Username        string
	Password        string
	CurrentRepo     string
)

func init() {
	services = make([]string, 0)
}
func GenerateClient() error {
	client = gen.NewFile(PackageName)
	client.Type().Id("Client").StructFunc(func(g *gen.Group) {
		g.Id("baseURL").Op("*").Qual("net/url", "URL")
		g.List(gen.Id("username"), gen.Id("password"), gen.Id("token")).String()
		g.Id("authType").Id("authType")
		g.Id("httpClient").Op("*").Qual("net/http", "Client")
		for _, service := range services {
			g.Id(strcase.ToCamel(service)).Op("*").Id(strcase.ToCamel(service) + "Service")
		}
	})
	client.Func().Id("NewClient").Params(gen.List(gen.Id("endpoint"), gen.Id("username"), gen.Id("password")).String()).Params(gen.Op("*").Id("Client"), gen.Error()).BlockFunc(func(g *gen.Group) {
		g.Id("c").Op(":=").Op("&Client{username: username, password: password, authType: basicAuth, httpClient: http.DefaultClient}")
		g.If(
			gen.Id("endpoint").Op("==").Lit(""),
		).Block(
			gen.Id("c").Dot("SetBaseURL").Call(gen.Id("defaultBaseURL")),
		).Else().Block(
			gen.If(gen.Err().Op(" := c.SetBaseURL(endpoint); err != nil").Block(
				gen.Return(gen.Nil(), gen.Err()),
			)),
		)
		for _, service := range services {
			g.Id("c").Dot(strcase.ToCamel(service)).Op("=&").Id(strcase.ToCamel(service) + "Service").Values(gen.Dict{gen.Id("client"): gen.Id("c")})
		}
		g.Return(gen.Id("c"), gen.Nil())
	})
	return client.Save(WorkingDir + "/client.go")
}
func Build(pkgName, workingDir, endpoint, username, password string, apidoc *api.API) error {
	WorkingDir = workingDir
	PackageName = pkgName
	Endpoint = endpoint
	Username = username
	Password = password
	_ = os.Mkdir(workingDir, os.ModeDir)

	//setup validation file
	validation = gen.NewFile(pkgName)
	validation.HeaderComment("[TODO] Code generated by \"github.com/magicsong/generate-go-for-sonarqube\", you should edit some validation logic here")
	validation.ImportName("github.com/magicsong/generate-go-for-sonarqube/pkg/validation", "validation")

	// add static file
	err := AddStaticFile()
	if err != nil {
		glog.Errorln("Import static files failed")
		return err
	}
	for _, item := range apidoc.WebServices {
		name := item.Path[4:]
		contin := false
		for _, word := range DeprecatedWords {
			if strings.Contains(strings.ToLower(item.Description), word) {
				glog.V(1).Infof("Detected deprecated api:%s,source:%s\n", item.Path, item.Description)
				contin = true
				break
			}
		}
		if contin {
			continue
		}
		services = append(services, name)
		newFile, err := os.Create(workingDir + "/" + name + "_service.go")
		glog.V(3).Infof("Creaing go file %s", newFile.Name())
		if err != nil {
			return err
		}
		defer newFile.Close()
		f, err := GenerateGoContent(PackageName, &item)
		if err != nil {
			return err
		}
		err = f.Render(newFile)
		if err != nil {
			return err
		}
	}
	if err = GenerateClient(); err != nil {
		glog.Errorln("Failed creating client codes")
		return err
	}
	//Write validation file
	return validation.Save(WorkingDir + "/validation.go")
}
func AddIntegrationFile(service *api.WebService) {
	serviceName := strcase.ToCamel(service.Path[4:])
	_ = os.MkdirAll("integration_testing/"+service.Path, os.ModeDir)
	f := gen.NewFile("main")
	f.ImportName("github.com/magicsong/color-glog", "glog")
	helperCode := `func TestHelper(action,service string, do doFunc){
		start:=time.Now()
		glog.Infof("Test action <%s> in service <%s>",action,service)
		if err:=doFunc();err!=nil{
			glog.Errorf("Test FAILED in %s of service %s, please check the error:%v",action,service,err)
			os.Exit(1)
		}
		glog.Infof("Test SUCCESSFUL in %s of service %s, elapsed time: %ds",action,service,time.Now().Sub(start).Seconds())
	}`
	f.Op(helperCode).Line()
	f.Func().Id("main").Call().BlockFunc(func(g *gen.Group) {
		g.Qual("flag", "parse").Call()
		for _, action := range service.Actions {
			actionName := strcase.ToCamel(action.Key)
			g.Id("TestHelper").Call(gen.Lit(actionName), gen.Lit(serviceName), gen.Id("Test"+actionName))
		}
		g.Qual("github.com/magicsong/color-glog", "Infoln").Call(gen.Lit("^_^ Test ALl Pass"))
	})
	for _, action := range service.Actions {
		actionName := strcase.ToCamel(action.Key)
		f.Func().Id("Test" + actionName).Call().Error().BlockFunc(func(g *gen.Group) {
			g.List(gen.Id("client"), gen.Err()).Op(":=").Qual("", "")
		})
	}
}
func AddStaticFile() error {
	s1 := fmt.Sprintf("package %s\n\n%s", PackageName, SonarqubeConst)
	s2 := fmt.Sprintf("package %s\n\n%s", PackageName, WebClientConst)
	err := ioutil.WriteFile(WorkingDir+"/sonarqube.go", []byte(s1), 0644)
	if err != nil {
		return err
	}
	return ioutil.WriteFile(WorkingDir+"/client_util.go", []byte(s2), 0644)
}

func GenerateGoContent(packageName string, service *api.WebService) (f *gen.File, err error) {
	if service == nil {
		return nil, errors.New("service must not be nil")
	}
	if packageName == "" {
		return nil, errors.New("package name is illegal")
	}
	f = gen.NewFile(packageName)

	f.PackageComment(service.Description)
	f.ImportName("github.com/google/glog", "glog")

	name := service.Path[4:]
	//Create Service Struct
	f.Type().Id(strcase.ToCamel(name) + "Service").Struct(
		gen.Id("client").Op("*").Id("Client"),
	).Line()

	//create main object
	fetcher := response.NewExampleFetcher(Endpoint, Username, Password)
	examples, err := fetcher.GetResponseExample(service)
	if err != nil {
		glog.Errorf("cannot fetch examples of <%s>", service.Path)
		return nil, err
	}
	strs := make([]string, 0)
	for _, exam := range examples {
		if exam.Format != "json" {
			glog.V(1).Infof("The response of action <%s> for api <%s> is %s, not json", exam.Name, name, exam.Format)
			continue
		}
		strs = append(strs, exam.Example)
	}
	if len(strs) != 0 {
		stru, err := UnionJSONToStruct(strs, strcase.ToCamel(name))
		if err != nil {
			glog.Warningf("cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, WorkingDir+"/"+name+"_service.go")
			glog.Errorln(err.Error())
			err = nil
			//because of the api is not normative,so we should ignore the error
			f.Commentf("[TODO] cannot generate resp struct of <%s>,you should manual edit the file %s,esspecial method response", service.Path, WorkingDir+"/"+name+"_service.go")
			f.Type().Id(strcase.ToCamel(name)).Struct().Line()
		} else {
			f.Id(stru).Line()
			f.Line()
		}
	}
	//Create Methods
	for _, item := range service.Actions {
		f.Add(GenerateServiceActionContent(name, &item))
	}
	return
}

//GenerateServiceActionContent generate code of each service,include api method and related structs
func GenerateServiceActionContent(serviceName string, action *api.Action) *gen.Statement {
	c := gen.Line()
	hasOption := true
	optionName := strcase.ToCamel(serviceName + "_" + action.Key + "Option")
	respName := strcase.ToCamel(serviceName)
	if len(action.Params) == 0 {
		hasOption = false
	}

	if hasOption {
		c.Type().Id(optionName).StructFunc(func(g *gen.Group) {
			for _, field := range action.Params {
				if strings.Contains(strings.ToLower(field.Description), "deprecated") {
					glog.V(1).Infof("Detected deprecated field <%s> in <action>:%s,description:%s\n", field.Key, action.Key, field.Description)
					continue
				}
				g.Id(strcase.ToCamel(field.Key)).String().Tag(map[string]string{"url": field.Key + ",omitempty"}).Commentf("Description:\"%s\",ExampleValue:\"%s\"", field.Description, field.ExampleValue)
			}
		}).Line()

		//create valid method
		validation.Func().Params(gen.Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id("Validate" + strcase.ToCamel(action.Key) + "Opt").Params(
			gen.Id("opt").Op("*").Id(optionName)).Params(gen.Op("*").Error()).Block(
			gen.Return(gen.Nil()),
		)
	}
	//create method
	method := "GET"
	if action.Post {
		method = "POST"
	}
	c.Commentf("%s %s", strcase.ToCamel(action.Key), action.Description).Line()
	c.Func().Params(gen.Id("s").Op("*").Id(strcase.ToCamel(serviceName) + "Service")).Id(strcase.ToCamel(action.Key)).ParamsFunc(func(g *gen.Group) {
		if hasOption {
			g.Id("opt").Op("*").Id(optionName)
		}
	}).ParamsFunc(func(g *gen.Group) {
		switch action.ResponseType {
		case "json", "xml":
			g.Id("resp").Op("*").Id(respName)
		case "txt", "log":
			g.Id("resp").Op("*").String()
			respName = "string"
		default:
			g.Id("resp").Op("*").String()
			respName = "string"
		}
		g.Err().Error()
	}).BlockFunc(func(g *gen.Group) {
		if hasOption {
			g.Err().Op("=").Id("s").Dot("Validate" + strcase.ToCamel(action.Key) + "Opt").Call(gen.Id("opt"))
			ErrorHandlerHelper(g)
		}
		g.List(gen.Id("req"), gen.Id("err")).Op(":=").Id("s").Dot("client").Dot("NewRequest").CallFunc(func(g *gen.Group) {
			g.Lit(method)
			g.Lit(serviceName + "/" + action.Key)
			if hasOption {
				g.Id("opt")
			} else {
				g.Nil()
			}
		})
		ErrorHandlerHelper(g)
		g.Id("resp").Op("=").New(gen.Id(respName))
		g.Err().Op("=").Id("s").Dot("client").Dot("Do").Call(gen.Id("req"), gen.Id("resp"))
		ErrorHandlerHelper(g)
		g.Return()
	})
	return c
}

func ErrorHandlerHelper(g *gen.Group) {
	g.If(
		gen.Err().Op("!=").Nil(),
	).Block(
		gen.Return(),
	)
}

func GetCurrentRepo(workingDir, currentDir string) (string, error) {
	gosrc := os.Getenv("GOPATH") + "/src"
	if currentDir[:len(gosrc)] != gosrc {
		return "", errors.New("current location is not in $GOPATH/src")
	}
	if len(currentDir) == len(gosrc) {
		return "", errors.New("current location should be in subdir of $GOPATH/src")
	}
	return currentDir[len(gosrc)+1:] + "/" + workingDir, nil
}
