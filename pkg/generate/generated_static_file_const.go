// Code generated by generate-go-for-sonarqub, DON'T mannualy edit it

package generate // import "github.com/magicsong/generate-go-for-sonarqube/pkg/generate"

const SonarqubeConst = "package sonarqube\r\n\r\nimport (\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\r\n\t\"github.com/google/go-querystring/query\"\r\n)\r\n\r\nconst (\r\n\tdefaultBaseURL = \"http://sonarqube.kubesphere.com/api/\"\r\n\tuserAgent      = \"devops server\"\r\n)\r\n\r\ntype authType int\r\n\r\nconst (\r\n\tbasicAuth authType = iota\r\n\toAuthToken\r\n\tprivateToken\r\n)\r\n\r\nfunc (c *Client) BaseURL() *url.URL {\r\n\tu := *c.baseURL\r\n\treturn &u\r\n}\r\n\r\n// SetBaseURL sets the base URL for API requests to a custom endpoint. urlStr\r\n// should always be specified with a trailing slash.\r\nfunc (c *Client) SetBaseURL(urlStr string) error {\r\n\tif u, err := SetBaseURLUtil(urlStr); err != nil {\r\n\t\treturn err\r\n\t} else {\r\n\t\tc.baseURL = u\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// NewRequest creates an API request. A relative URL path can be provided in\r\n// urlStr, in which case it is resolved relative to the base URL of the Client.\r\n// Relative URL paths should always be specified without a preceding slash. If\r\n// specified, the value pointed to by body is JSON encoded and included as the\r\n// request body.\r\nfunc (c *Client) NewRequest(method, path string, opt interface{}) (*http.Request, error) {\r\n\tu := *c.baseURL\r\n\t// Set the encoded opaque data\r\n\tu.Opaque = c.baseURL.Path + path\r\n\r\n\tif opt != nil {\r\n\t\tq, err := query.Values(opt)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tu.RawQuery = q.Encode()\r\n\t}\r\n\r\n\treq := &http.Request{\r\n\t\tMethod:     method,\r\n\t\tURL:        &u,\r\n\t\tProto:      \"HTTP/1.1\",\r\n\t\tProtoMajor: 1,\r\n\t\tProtoMinor: 1,\r\n\t\tHeader:     make(http.Header),\r\n\t\tHost:       u.Host,\r\n\t}\r\n\r\n\tif method == \"POST\" || method == \"PUT\" {\r\n\t\t// SonarQube use RawQuery even method is POST\r\n\t\t// bodyBytes, err := json.Marshal(opt)\r\n\t\t// if err != nil {\r\n\t\t// \treturn nil, err\r\n\t\t// }\r\n\t\t// bodyReader := bytes.NewReader(bodyBytes)\r\n\r\n\t\t// u.RawQuery = \"\"\r\n\t\t// req.Body = ioutil.NopCloser(bodyReader)\r\n\t\t// req.ContentLength = int64(bodyReader.Len())\r\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\t}\r\n\r\n\treq.Header.Set(\"Accept\", \"application/json\")\r\n\r\n\tswitch c.authType {\r\n\tcase basicAuth, oAuthToken:\r\n\t\treq.SetBasicAuth(c.username, c.password)\r\n\tcase privateToken:\r\n\t\treq.SetBasicAuth(c.token, \"\")\r\n\t}\r\n\treq.Header.Set(\"User-Agent\", userAgent)\r\n\treturn req, nil\r\n}\r\n\r\n// Do sends an API request and returns the API response. The API response is\r\n// JSON decoded and stored in the value pointed to by v, or returned as an\r\n// error if an API error has occurred. If v implements the io.Writer\r\n// interface, the raw response body will be written to v, without attempting to\r\n// first decode it.\r\nfunc (c *Client) Do(req *http.Request, v interface{}) error {\r\n\treturn webclient.Do(c.httpClient, req, v)\r\n}\r\n"
const WebClientConst = ""
