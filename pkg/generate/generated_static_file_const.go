// Code generated by generate-go-for-sonarqub, DON'T mannualy edit it

package generate

const SonarqubeConst = "import (\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\r\n\t\"github.com/google/go-querystring/query\"\r\n)\r\n\r\nconst (\r\n\tdefaultBaseURL = \"http://sonarqube.kubesphere.com/api/\"\r\n\tuserAgent      = \"devops server\"\r\n)\r\n\r\ntype authType int\r\n\r\nconst (\r\n\tbasicAuth authType = iota\r\n\toAuthToken\r\n\tprivateToken\r\n)\r\n\r\nconst (\r\n\tQualifierSubProject = \"BRC\"\r\n\tQualifierDirectory  = \"DIR\"\r\n\tQualifierFile       = \"FIL\"\r\n\tQualifierProject    = \"TRK\"\r\n\tQualifierTestFile   = \"UTS\"\r\n)\r\nfunc (c *Client) BaseURL() *url.URL {\r\n\tu := *c.baseURL\r\n\treturn &u\r\n}\r\n\r\n// SetBaseURL sets the base URL for API requests to a custom endpoint. urlStr\r\n// should always be specified with a trailing slash.\r\nfunc (c *Client) SetBaseURL(urlStr string) error {\r\n\tif u, err := SetBaseURLUtil(urlStr); err != nil {\r\n\t\treturn err\r\n\t} else {\r\n\t\tc.baseURL = u\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// NewRequest creates an API request. A relative URL path can be provided in\r\n// urlStr, in which case it is resolved relative to the base URL of the Client.\r\n// Relative URL paths should always be specified without a preceding slash. If\r\n// specified, the value pointed to by body is JSON encoded and included as the\r\n// request body.\r\nfunc (c *Client) NewRequest(method, path string, opt interface{}) (*http.Request, error) {\r\n\tu := *c.baseURL\r\n\t// Set the encoded opaque data\r\n\tu.Opaque = c.baseURL.Path + path\r\n\r\n\tif opt != nil {\r\n\t\tq, err := query.Values(opt)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tu.RawQuery = q.Encode()\r\n\t}\r\n\r\n\treq := &http.Request{\r\n\t\tMethod:     method,\r\n\t\tURL:        &u,\r\n\t\tProto:      \"HTTP/1.1\",\r\n\t\tProtoMajor: 1,\r\n\t\tProtoMinor: 1,\r\n\t\tHeader:     make(http.Header),\r\n\t\tHost:       u.Host,\r\n\t}\r\n\r\n\tif method == \"POST\" || method == \"PUT\" {\r\n\t\t// SonarQube use RawQuery even method is POST\r\n\t\t// bodyBytes, err := json.Marshal(opt)\r\n\t\t// if err != nil {\r\n\t\t// \treturn nil, err\r\n\t\t// }\r\n\t\t// bodyReader := bytes.NewReader(bodyBytes)\r\n\r\n\t\t// u.RawQuery = \"\"\r\n\t\t// req.Body = ioutil.NopCloser(bodyReader)\r\n\t\t// req.ContentLength = int64(bodyReader.Len())\r\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\t}\r\n\r\n\treq.Header.Set(\"Accept\", \"application/json\")\r\n\r\n\tswitch c.authType {\r\n\tcase basicAuth, oAuthToken:\r\n\t\treq.SetBasicAuth(c.username, c.password)\r\n\tcase privateToken:\r\n\t\treq.SetBasicAuth(c.token, \"\")\r\n\t}\r\n\treq.Header.Set(\"User-Agent\", userAgent)\r\n\treturn req, nil\r\n}\r\n\r\n// Do sends an API request and returns the API response. The API response is\r\n// JSON decoded and stored in the value pointed to by v, or returned as an\r\n// error if an API error has occurred. If v implements the io.Writer\r\n// interface, the raw response body will be written to v, without attempting to\r\n// first decode it.\r\nfunc (c *Client) Do(req *http.Request, v interface{}) (*http.Response,error) {\r\n\treturn Do(c.httpClient, req, v)\r\n}\r\n\r\n//Paging is used in many apis\r\ntype Paging struct {\r\n\tPageIndex int64 `json:\"pageIndex,omitempty\"`\r\n\tPageSize  int64 `json:\"pageSize,omitempty\"`\r\n\tTotal     int64 `json:\"total,omitempty\"`\r\n}"
const WebClientConst = "import (\r\n\t\"bytes\"\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"io\"\r\n\t\"io/ioutil\"\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\t\"sort\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/google/go-querystring/query\"\r\n)\r\n\r\n// SetBaseURL sets the base URL for API requests to a custom endpoint. urlStr\r\n// should always be specified with a trailing slash.\r\nfunc SetBaseURLUtil(urlStr string) (*url.URL, error) {\r\n\t// Make sure the given URL end with a slash\r\n\tif !strings.HasSuffix(urlStr, \"/\") {\r\n\t\turlStr += \"/\"\r\n\t}\r\n\r\n\tbaseURL, err := url.Parse(urlStr)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\t// Update the base URL of the client.\r\n\treturn baseURL, nil\r\n}\r\n\r\n// NewRequest creates an API request. A relative URL path can be provided in\r\n// urlStr, in which case it is resolved relative to the base URL of the Client.\r\n// Relative URL paths should always be specified without a preceding slash. If\r\n// specified, the value pointed to by body is JSON encoded and included as the\r\n// request body.\r\nfunc NewRequest(method, path string, baseURL *url.URL, username, password string, opt interface{}) (*http.Request, error) {\r\n\t// Set the encoded opaque data\r\n\tu := *baseURL\r\n\tunescaped, err := url.PathUnescape(path)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tu.RawPath = u.Path + path\r\n\tu.Path = u.Path + unescaped\r\n\tif opt != nil {\r\n\t\tq, err := query.Values(opt)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tu.RawQuery = q.Encode()\r\n\t}\r\n\r\n\treq := &http.Request{\r\n\t\tMethod: method,\r\n\t\tURL:    &u,\r\n\t\tProto:  \"HTTP/1.1\",\r\n\t\tHeader: make(http.Header),\r\n\t\tHost:   u.Host,\r\n\t}\r\n\r\n\tif method == \"POST\" || method == \"PUT\" {\r\n\t\t//SonarQube use RawQuery even method is POST\r\n\t\tbodyBytes, err := json.Marshal(opt)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tbodyReader := bytes.NewReader(bodyBytes)\r\n\r\n\t\tu.RawQuery = \"\"\r\n\t\treq.Body = ioutil.NopCloser(bodyReader)\r\n\t\treq.ContentLength = int64(bodyReader.Len())\r\n\t\treq.Header.Set(\"Content-Type\", \"application/json\")\r\n\t}\r\n\r\n\treq.Header.Set(\"Accept\", \"application/json\")\r\n\treq.SetBasicAuth(username, password)\r\n\treturn req, nil\r\n}\r\n\r\n// Do sends an API request and returns the API response. The API response is\r\n// JSON decoded and stored in the value pointed to by v, or returned as an\r\n// error if an API error has occurred. If v implements the io.Writer\r\n// interface, the raw response body will be written to v, without attempting to\r\n// first decode it.\r\nfunc Do(c *http.Client, req *http.Request, v interface{}) (*http.Response,error) {\r\n\tisText := false\r\n\tif _, ok := v.(*string); ok {\r\n\t\treq.Header.Set(\"Accept\", \"text/plain\")\r\n\t\tisText = true\r\n\t}\r\n\tresp, err := c.Do(req)\r\n\tif err != nil {\r\n\t\treturn nil,err\r\n\t}\r\n\tdefer resp.Body.Close()\r\n\terr = CheckResponse(resp)\r\n\tif err != nil {\r\n\t\treturn resp,err\r\n\t}\r\n\tif v != nil {\r\n\t\tif w, ok := v.(io.Writer); ok {\r\n\t\t\t_, err = io.Copy(w, resp.Body)\r\n\t\t} else {\r\n\t\t\tif isText {\r\n\t\t\t\tbyts, err := ioutil.ReadAll(resp.Body)\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\treturn resp,err\r\n\t\t\t\t}\r\n\t\t\t\tw := v.(*string)\r\n\t\t\t\t*w = string(byts)\r\n\t\t\t} else {\r\n\t\t\t\terr = json.NewDecoder(resp.Body).Decode(v)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn resp,err\r\n}\r\n\r\ntype ErrorResponse struct {\r\n\tBody     []byte\r\n\tResponse *http.Response\r\n\tMessage  string\r\n}\r\n\r\nfunc (e *ErrorResponse) Error() string {\r\n\tpath, _ := url.QueryUnescape(e.Response.Request.URL.Path)\r\n\tu := fmt.Sprintf(\"%s://%s%s\", e.Response.Request.URL.Scheme, e.Response.Request.URL.Host, path)\r\n\treturn fmt.Sprintf(\"%s %s: %d %s\", e.Response.Request.Method, u, e.Response.StatusCode, e.Message)\r\n}\r\nfunc CheckResponse(r *http.Response) error {\r\n\tswitch r.StatusCode {\r\n\tcase 200, 201, 202, 204, 304:\r\n\t\treturn nil\r\n\t}\r\n\r\n\terrorResponse := &ErrorResponse{Response: r}\r\n\tdata, err := ioutil.ReadAll(r.Body)\r\n\tif err == nil && data != nil {\r\n\t\terrorResponse.Body = data\r\n\r\n\t\tvar raw interface{}\r\n\t\tif err := json.Unmarshal(data, &raw); err != nil {\r\n\t\t\terrorResponse.Message = string(data)\r\n\t\t} else {\r\n\t\t\terrorResponse.Message = parseError(raw)\r\n\t\t}\r\n\t}\r\n\r\n\treturn errorResponse\r\n}\r\nfunc parseError(raw interface{}) string {\r\n\tswitch raw := raw.(type) {\r\n\tcase string:\r\n\t\treturn raw\r\n\r\n\tcase []interface{}:\r\n\t\tvar errs []string\r\n\t\tfor _, v := range raw {\r\n\t\t\terrs = append(errs, parseError(v))\r\n\t\t}\r\n\t\treturn fmt.Sprintf(\"[%s]\", strings.Join(errs, \", \"))\r\n\r\n\tcase map[string]interface{}:\r\n\t\tvar errs []string\r\n\t\tfor k, v := range raw {\r\n\t\t\terrs = append(errs, fmt.Sprintf(\"{%s: %s}\", k, parseError(v)))\r\n\t\t}\r\n\t\tsort.Strings(errs)\r\n\t\treturn strings.Join(errs, \", \")\r\n\r\n\tdefault:\r\n\t\treturn fmt.Sprintf(\"failed to parse unexpected error type: %T\", raw)\r\n\t}\r\n}\r\n"
const TestSuiteConst = "import (\r\n\t\"testing\"\r\n\t\"os\"\r\n\r\n\t{REPLACE_PACKAGENAME}\r\n\t. \"github.com/onsi/ginkgo\"\r\n\t. \"github.com/onsi/gomega\"\r\n)\r\n\r\nvar client *Client\r\nvar _ = BeforeSuite(func() {\r\n\tsonarURL := os.Getenv(\"SONAR_URL\")\r\n\tif sonarURL == \"\" {\r\n\t\tFail(\"SONAR_URL should not be empty\")\r\n\t}\r\n\tc, err := NewClient(sonarURL+\"/api\", \"admin\", \"admin\")\r\n\tExpect(err).ShouldNot(HaveOccurred())\r\n\tclient = c\r\n})\r\n\r\nfunc TestSonar(t *testing.T) {\r\n\tRegisterFailHandler(Fail)\r\n\tRunSpecs(t, \"Sonar Suite\")\r\n}\r\n\r\n\r\n"
